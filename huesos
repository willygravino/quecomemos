
@login_required
def lista_de_compras(request):
    # locale.setlocale(locale.LC_TIME, 'es_ES.UTF-8')  # Configura la localizaci√≥n a espa√±ol

    locale.setlocale(locale.LC_TIME, 'C')

    # Obtener la fecha actual
    today = date.today()

    lista_de_ingredientes = set()
    ingredientes_unicos = {}  # Diccionario para almacenar ingredientes a comprar, estado, comentario
    lista_de_compras = set()
    no_elegidos = set()
    ingredientes_elegidos = set()

    # Filtrar los objetos de ElegidosXDia para excluir aquellos cuya fecha sea anterior a la fecha actual
    menues_del_usuario = ElegidosXDia.objects.filter(user=request.user, el_dia_en_que_comemos__gte=today).order_by('el_dia_en_que_comemos')

    # menues_del_usuario = ComidaDelDia.objects.filter(user=request.user, fecha__gte=today).order_by('fecha', 'momento')

    # Obtener el perfil del usuario actual
    perfil = get_object_or_404(Profile, user=request.user)

    # VARIABLES PARA PRUEBAS
    # ingrediente_limpio = set()
    # ingredientes_elegidos_calculados = set()
    # no_elegidos_calculados = set()
    # clave_fecha = ""
    # variedades_seleccionadas = ""

    def norm(s: str) -> str:
        return (s or "").strip().lower()
    
    ingredientes_elegidos = set(request.POST.getlist("ingrediente_a_comprar"))

    if request.method == 'POST':
        # 1) Estructuras auxiliares
        # platos seleccionados: set de claves "platoId_fecha"
        platos_seleccionados = set(request.POST.getlist("plato_seleccionado"))  # p.ej. {"155_20250926", ...}

        # variedades seleccionadas por clave_fecha
        # Ej: variedades_sel["155_20250926"] = {"con huevo", "sin huevo"}
        variedades_sel = defaultdict(set)
        for value in request.POST.getlist("variedad_seleccionada"):
            try:
                clave_plato_fecha, nombre_var = value.split("|", 1)  # "155_20250926" | "con huevo"
            except ValueError:
                continue
            variedades_sel[clave_plato_fecha].add(norm(nombre_var))

        # 2) Recorrer men√∫s y actualizar true / false seg√∫n lo que lleg√≥ del form
        for menu in menues_del_usuario:
            platos = menu.platos_que_comemos or {}
            fecha_menu = menu.el_dia_en_que_comemos.strftime("%Y%m%d")

            for comida, lista_platos in platos.items():
                for plato in lista_platos:
                    plato_id = str(plato.get("id_plato", ""))
                    clave_fecha = f"{plato_id}_{fecha_menu}"

                    if clave_fecha in platos_seleccionados:
                        plato_estaba_elegido = plato.get("elegido", False)
                        # Si antes era False y ahora (seg√∫n el form) es True
                        if (clave_fecha in platos_seleccionados) and not plato_estaba_elegido:
                                ingred_plato_agregado = {
                                    ing.strip() for ing in (plato.get("ingredientes") or "").split(",") if ing.strip()
                                }
                                if ingred_plato_agregado:
                                    ingredientes_tengo = set(perfil.ingredientes_que_tengo)
                                    # no_elegidos_calculados = ingred_variedad_agregada & ingredientes_tengo
                                    # ingredientes_elegidos_calculados |= ingred_variedad_agregada - ingredientes_tengo
                                    no_elegidos = ingred_plato_agregado & ingredientes_tengo
                                    ingredientes_elegidos |= ingred_plato_agregado - ingredientes_tengo

                        # Actualiza el estado (sin usar variable intermedia)
                        plato["elegido"] = True

                        # Variedades: comparamos por NOMBRE normalizado (lo que llega del form)
                        seleccionadas = variedades_sel.get(clave_fecha, set())
                        
                        for _, var_data in (plato.get("variedades") or {}).items():
                            nombre_var = var_data.get("nombre")
                            var_estaba_elegida = var_data.get("elegido", False)

                            # Si antes era False y ahora (seg√∫n el form) es True
                            if (nombre_var in seleccionadas) and not var_estaba_elegida:
                                ingred_variedad_agregada = {
                                    ing.strip() for ing in (var_data.get("ingredientes") or "").split(",") if ing.strip()
                                }
                                if ingred_variedad_agregada:
                                    ingredientes_tengo = set(perfil.ingredientes_que_tengo)
                                    # no_elegidos_calculados = ingred_variedad_agregada & ingredientes_tengo
                                    # ingredientes_elegidos_calculados |= ingred_variedad_agregada - ingredientes_tengo
                                    no_elegidos = ingred_variedad_agregada & ingredientes_tengo
                                    ingredientes_elegidos |= ingred_variedad_agregada - ingredientes_tengo

                            # Actualiza el estado (sin usar variable intermedia)
                            var_data["elegido"] = (nombre_var in seleccionadas)
                        
                    else:
                        plato["elegido"] = False
                        for var_data in (plato.get("variedades") or {}).values():
                            var_data["elegido"] = False

            # 3) Persistir
            menu.platos_que_comemos = platos
            menu.save()

        # Suponiendo que perfil.comentarios contiene una lista de cadenas en el formato "ingrediente%comentario"
        comentarios_guardados_lista = perfil.comentarios
        comentarios_guardados = {}

        if comentarios_guardados_lista:
            # Recorrer los comentarios guardados y convertirlos en un diccionario
            for item in comentarios_guardados_lista:
                ingrediente, comentario = item.split("%", 1)  # Divide en ingrediente y comentario
                comentarios_guardados[ingrediente] = comentario  # Guarda en el diccionario

        comentarios_posteados = {}

        for key, value in request.POST.items():
            if key.endswith("_comentario"):  # Filtra solo los comentarios
                ingrediente = key.replace("_comentario", "")  # Extraer el ingrediente del nombre del campo
                comentario_posteado = value.strip()  # Eliminar espacios en blanco al inicio y al final

                # Guarda el comentario (puede ser vac√≠o)
                comentarios_posteados[ingrediente] = comentario_posteado

        # Recorremos el diccionario de comentarios guardados
        for ingrediente_posteado, comentario_posteado in comentarios_posteados.items():
            if ingrediente_posteado in comentarios_guardados:  # Verificamos si el ingrediente est√° en ambos diccionarios
                # Obtenemos el comentario guardado
                comentario_guardado = comentarios_guardados[ingrediente_posteado]
                # prepara el registro nuevo por si lo usa
                registro = f"{ingrediente_posteado}%{comentario_guardado}"
                if not comentario_posteado:
                    # Eliminar el comentario del ingrediente
                    perfil.comentarios.remove(registro)
                elif comentario_posteado != comentario_guardado:
                        # Actualizar el comentario del ingrediente
                    perfil.comentarios[perfil.comentarios.index(registro)] = f"{ingrediente_posteado}%{comentario_posteado}"

            elif comentario_posteado:
                # Unir el ingrediente nuevo con el comentario, separado por '%'
                ingrediente_con_comentario = f"{ingrediente_posteado}%{comentario_posteado}"
                # Actualizar el campo ingredientes_que_tengo
                perfil.comentarios.append(ingrediente_con_comentario)

            # Guardar los cambios en el perfil
            perfil.save()
    
    # Recorrer los men√∫s del usuario
    for menu in menues_del_usuario:
        platos = menu.platos_que_comemos or []  # Asegurar que no sea None, sino una lista vac√≠a

        # Recorrer las comidas del usuario (desayuno, almuerzo, cena, etc.)
        for comida, lista_platos in platos.items():
            # Recorrer cada plato en la comida
            for datos in lista_platos:
                # Si el plato est√° marcado como elegido, a√±adimos sus ingredientes
                if datos.get("elegido") and datos.get("ingredientes"):
                    lista_de_ingredientes.update(map(str.strip, datos["ingredientes"].split(",")))

                # Recorrer variedades si existen y est√°n marcadas como elegidas
                for variedad in datos.get("variedades", {}).values():
                    if variedad.get("elegido"):
                        lista_de_ingredientes.update(map(str.strip, variedad["ingredientes"].split(",")))
                     
    if ingredientes_elegidos:
        no_elegidos = lista_de_ingredientes - ingredientes_elegidos
        for ingrediente_a_comprar in lista_de_ingredientes:
            if ingrediente_a_comprar in perfil.ingredientes_que_tengo:
                # Eliminar el ingrediente de la lista
                perfil.ingredientes_que_tengo.remove(ingrediente_a_comprar)
                # Guardar el perfil actualizado
                perfil.save()
    elif request.method != "GET":
        no_elegidos = lista_de_ingredientes    
                
    if no_elegidos:
        for ingrediente in no_elegidos:
            if ingrediente not in perfil.ingredientes_que_tengo:
                # Actualizar el campo ingredientes_que_tengo
                perfil.ingredientes_que_tengo.append(ingrediente)
                # Guardar el perfil actualizado
                perfil.save()
   
    if lista_de_ingredientes:
        for ingrediente in lista_de_ingredientes:
            el_comentario = ""
            # Recorrer la lista y buscar el comentario asociado
            for item in perfil.comentarios:
                # if "%" in item:
                ingrediente_archivado, comentario = item.split("%", 1)  # Dividir en ingrediente y comentario
                if ingrediente_archivado == ingrediente:
                    el_comentario = comentario

            if ingrediente in perfil.ingredientes_que_tengo:
                ingredientes_unicos [ingrediente] = {
                    "comentario": el_comentario,
                    "estado": "tengo" }
            else:
                ingredientes_unicos [ingrediente] = {
                    "comentario": el_comentario,
                    "estado": "no-tengo" }
   
    lista_de_compras =[]
    # Recorrer el diccionario para formatear los ingredientes que no tienes
    for ingrediente, detalles in ingredientes_unicos.items():
        if detalles["estado"] == "no-tengo":
            comentario = detalles["comentario"]
            # Formatear el ingrediente con el comentario si est√° presente
            if comentario:
                # mensaje_whatsapp += f"‚Ä¢ {ingrediente} ({comentario})\n"
                lista_de_compras.append(f"{ingrediente} ({comentario})")

            else:
                # mensaje_whatsapp += f"‚Ä¢ {ingrediente}\n"
                lista_de_compras.append(f"{ingrediente}")
    
    token = perfil.ensure_share_token()  # genera uno si no existe

    share_url = request.build_absolute_uri(
        reverse("compartir-lista", args=[token]))

    context = {
        'menues_del_usuario': menues_del_usuario,
        'ingredientes_con_tengo_y_comentario': ingredientes_unicos, # DICT TODOS LOS INGREDIENTES, CON TENGO Y COMENTARIO
        "lista_de_compras": lista_de_compras, # LISTA DE COMPRAS PARA VERLO EN ENVAR A WHATS APP
        "parametro" : "lista-compras",
        'share_url': share_url,             # üëà NUEVO
        "lista_de_ingredientes": lista_de_ingredientes,
        "no_elegidos": no_elegidos,
        "ingredientes_elegidos": ingredientes_elegidos,
        # "ingredientes_elegidos_calculados": ingredientes_elegidos_calculados,
        # "no_elegidos_calculados" : no_elegidos_calculados,
        
     }

    return render(request, 'AdminVideos/lista_de_compras.html', context)